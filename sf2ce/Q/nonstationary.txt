import numpy

SIZE = 5

HQ  = {}
Q  = numpy.random.rand(SIZE)
R  = numpy.zeros(SIZE)
TS = numpy.zeros(SIZE)

for i in range(4):
    Q  = numpy.random.rand(SIZE)
    HQ[chr(i+64)] = [Q, [0,0], R, TS]

for s in HQ:
    Q   = HQ[s][0]
    hit = HQ[s][1]
    R   = HQ[s][2]
    TS  = HQ[s][3]

    print s, Q, hit, R, TS

a = numpy.argmax(HQ['A'][0])
print a

previous = 'C'
current = 'A'

a = HQ[previous][0][3]
print a

a = HQ[current][0][3]
print a


'''
for k, v in HQ.items():
    print k, v
'''

'''
Q = np.zeros([env.observation_space.n,env.action_space.n])
lr = .85
y  = .99

rList = []
for i in range(num_episodes):
    s = env.reset()

    while j < 99:

        a = np.argmax(Q[s,:] + np.random.randn(1,env.action_space.n) * (1./(i+1)))

        s1,r,d,_ = env.step(a)

        Q[s,a] = Q[s,a] + lr*(r + y*np.max(Q[s1,:]) - Q[s,a])

        s = s1
'''


'''
def minus(q):
    q.QR[s][a] -= 0.01

def plus(q):
    q.QR[s][a] += 0.01
'''

H = {}
def chop(h, s):
    hchop = ''
    hc = str(h)
    for i in range(s):
        hchop += hc[i]
    return hchop

def qts(ts, hchop):
    t = ts[1]
    try:
        print("%d %d (%.3f %.3f %.3f) - %s" %(len(H), len(t), numpy.quantile(t, 0.25), numpy.quantile(t, 0.50), numpy.quantile(t, 0.75), hchop))
    except:
        pass

with mss.mss() as sct:

    ts        = [0, []]

    while [ 1 ]:

        ts[0] = time.time()

                h = hash.compute(Image.fromarray(blue))
                hchop = chop(h, len(str(h))/2)
                H[hchop] = hchop 

                qts(ts, hchop)

                if len(ts[1]) > 1000:
                    ts[1].pop(0)
                    ts[1].append(time.time() - ts[0])
                else:
                    ts[1].append(time.time() - ts[0])
                    ts[0] = ts[1]


que
===

act, wait/que, recv[reward/penalty/0] - blocking(timeout)

def preact(hash, sumb1, sumb2):

  while [ 1 ]:

    hash.currenthit[0], hash.currenthit[1] = (0.4089536-sumb1/10000000.0), (0.4089536-sumb2/10000000.0)

    hit = [0, 0]
    #rlock
    hit[0], hit[1] = hash.currenthit[0] - hash.prevhit[0], hash.currenthit[1] - hash.prevhit[1]
    hit[0], hit[1] =  -1 if hit[0] else 0, 1 if hit[1] else 0
    #rlock

    if hit[0] != 0:
        que.put((-1))
        que.put((0))
    if hit[1] != 0:
        que.put((1))
        que.put((0))






        def _act(hit, hcurr, r, que):
        if hit[0] == 0 and hit[1] == 0:
            r = q.act(hcurr, hash.p)
            print r
            ryu.act(r)
            hq = que.get(1)
            print hq
            que.put((0))


...
  -1 1

...
  [s]
  act(r)
  que.get(2)
  que.put(0)

resumable,multi-trainning
